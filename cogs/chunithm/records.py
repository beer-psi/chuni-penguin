import asyncio
import contextlib
import itertools
import urllib.parse
from argparse import ArgumentError
from datetime import UTC, datetime
from decimal import Decimal
from io import BytesIO
from pathlib import Path
from typing import TYPE_CHECKING, Literal, Optional, cast

import discord
from discord import AllowedMentions, Interaction, app_commands
from discord.ext import commands
from discord.ext.commands import Context
from discord.utils import escape_markdown
from PIL import Image, ImageDraw, ImageEnhance, ImageFilter, ImageFont
from sqlalchemy import select
from sqlalchemy.orm import joinedload

from chunithm_net.consts import (
    INTERNATIONAL_JACKET_BASE,
    JACKET_BASE,
    KEY_INTERNAL_LEVEL,
    KEY_OVERPOWER_BASE,
    KEY_OVERPOWER_MAX,
    KEY_PLAY_RATING,
    KEY_SONG_ID,
    KEY_SONG_VERSION,
)
from chunithm_net.models.enums import ComboType, Difficulty, Genres, Rank
from chunithm_net.models.record import (
    DetailedRecentRecord,
    RecentRecord,
    Record,
)
from database.models import SongJacket
from utils import did_you_mean_text, floor_to_ndp, shlex_split
from utils.argparse import DiscordArguments
from utils.components import ScoreCardEmbed
from utils.constants import CURRENT_CHUNITHM_VERSION, SIMILARITY_THRESHOLD
from utils.kamaitachi import convert_kt_pbs_to_records, convert_kt_scores_to_records
from utils.views import B30View, CompareView, RecentRecordsView, SelectToCompareView

if TYPE_CHECKING:
    from bot import ChuniBot
    from cogs.autocompleters import AutocompletersCog
    from cogs.botutils import UtilsCog


ASSETS_DIR = Path(__file__).parent.parent.parent / "assets"
NOTO_SANS_JP_80 = ImageFont.truetype(
    ASSETS_DIR / "fonts" / "NotoSansJP-Regular.ttf", 80
)
NOTO_SANS_JP_28_MEDIUM = ImageFont.truetype(
    ASSETS_DIR / "fonts" / "NotoSansJP-Medium.ttf", 28
)
NOTO_SANS_JP_32_BOLD = ImageFont.truetype(
    ASSETS_DIR / "fonts" / "NotoSansJP-Bold.ttf", 32
)
INTER_32 = ImageFont.truetype(ASSETS_DIR / "fonts" / "Inter_28pt-Regular.ttf", 32)
B30_ENTRY_WIDTH = 350
B30_ENTRY_HEIGHT = 180


class reversor:
    def __init__(self, obj):
        self.obj = obj

    def __eq__(self, other):
        return other.obj == self.obj

    def __lt__(self, other):
        return other.obj < self.obj


def render_b30(
    player_name: str,
    records: list[Record],
    current_rating: float | None = None,
    max_rating: float | None = None,
):
    b30_image = Image.new("RGBA", size=(1872, 1784), color="#FFFFFF")
    b30_draw = ImageDraw.Draw(b30_image)

    with Image.open(ASSETS_DIR / "b30_bg.png") as im:
        im = im.resize((im.width * b30_image.height // im.height, b30_image.height))
        b30_image.paste(im.filter(ImageFilter.GaussianBlur(8)))

    # header: player name and credits
    # draw a background for the player name
    b30_draw.rectangle(
        (0, 0, b30_image.width, b30_image.height * 7 // 100), fill="#F2ACE0"
    )

    # draw the player name
    b30_draw.text((20, 0), player_name, fill="#000000", font=NOTO_SANS_JP_80)

    # determine the width/height of the credits text to right-align it with Math
    credits_bbox = b30_draw.multiline_textbbox(
        (0, 0),
        "Generated by chuni penguin#3217\nhttps://chunithm.beerpsi.cc/invite",
        INTER_32,
        spacing=12,
    )
    credits_width = credits_bbox[2] - credits_bbox[0]
    credits_height = credits_bbox[3] - credits_bbox[1]

    # draw the credit text
    b30_draw.multiline_text(
        (
            b30_image.width - credits_width - 30,
            (b30_image.height * 7 // 100 - credits_height) // 2 - 6,
        ),
        "Generated by chuni penguin#3217\nhttps://chunithm.beerpsi.cc/invite",
        fill="#000000",
        font=INTER_32,
        spacing=12,
    )

    total_rating = sum(
        (item.extras[KEY_PLAY_RATING] for item in records), start=Decimal(0)
    )
    max_play_rating = max(item.extras[KEY_PLAY_RATING] for item in records)
    average = floor_to_ndp(total_rating / len(records), 4)
    reachable = floor_to_ndp(total_rating / 40 + max_play_rating / 4, 4)

    # subheader: rating information and generation date
    # draw a background for the subheader
    b30_draw.rectangle(
        (0, b30_image.height * 7 // 100, b30_image.width, b30_image.height * 12 // 100),
        fill="#F2D0F0",
    )
    # draw the rating information in the subheader
    rating_text = f"AVERAGE {average:.4f} / REACHABLE {reachable:.4f}"

    if max_rating is not None:
        rating_text = f"MAX {max_rating:.2f} / {rating_text}"

    if current_rating is not None:
        rating_text = f"RATING {current_rating:.2f} / {rating_text}"

    b30_draw.text(
        (30, b30_image.height * 8.5 // 100),
        rating_text,
        fill="#000000",
        font=INTER_32,
    )

    # determine the size of the timestamp to properly right-align it
    updated_text = f"Generated at {datetime.now(UTC).strftime('%Y-%m-%d')}"
    updated_length = b30_draw.textlength(updated_text, INTER_32)

    b30_draw.text(
        (
            b30_image.width - updated_length - 30,
            b30_image.height * 8.5 // 100,
        ),
        updated_text,
        fill="#000000",
        font=INTER_32,
    )

    # best30
    # add a gaussian blurred shadow onto the jacket
    # generate the base shadow here so we can just copy it for each jacket later
    jacket_shadow_base = Image.new(
        "RGBA", (B30_ENTRY_WIDTH + 20, B30_ENTRY_HEIGHT + 20)
    )
    jacket_shadow_base.paste(
        (0, 0, 0, 200), (5, 5, B30_ENTRY_WIDTH + 15, B30_ENTRY_HEIGHT + 15)
    )

    for _ in range(5):
        jacket_shadow_base = jacket_shadow_base.filter(ImageFilter.GaussianBlur)

    for i, record in enumerate(records):
        # top left corner of each b30 entry
        # - the initial 30 is left/top margin
        # - the (i % 5) and (i // 5) are the b30's position on the grid, so this goes
        # left to right, top to bottom
        # - the width/height is added by 15 to space out the entries
        x = 30 + (i % 5) * (B30_ENTRY_WIDTH + 15)
        y = 30 + (b30_image.height * 12 // 100) + (i // 5) * (B30_ENTRY_HEIGHT + 15)

        jacket_path = ASSETS_DIR / "jackets" / f"{record.extras[KEY_SONG_ID]}.png"

        # we use try/catch on jacket processing to gracefully fail to a black image
        # if the jacket is missing or corrupted
        try:
            with Image.open(jacket_path) as jacket:
                # convert the jacket to RGB since ImageEnhance explodes in different modes
                # resize the jacket to B30_ENTRY_WIDTH so we can crop the center out
                jacket = jacket.convert("RGB").resize(
                    (B30_ENTRY_WIDTH, jacket.height * B30_ENTRY_WIDTH // jacket.width)
                )

                # crop the center so we have a B30_ENTRY_WIDTH * B30_ENTRY_HEIGHT image
                jacket = jacket.crop(
                    (
                        (jacket.width - B30_ENTRY_WIDTH) // 2,
                        (jacket.height - B30_ENTRY_HEIGHT) // 2,
                        (jacket.width + B30_ENTRY_WIDTH) // 2,
                        (jacket.height + B30_ENTRY_HEIGHT) // 2,
                    )
                )

                # darken the image and blur it
                jacket = (
                    ImageEnhance.Brightness(jacket)
                    .enhance(0.45)
                    .filter(ImageFilter.GaussianBlur(4))
                )
        except (FileNotFoundError, ValueError):
            # fallback to a black background if anything fails
            jacket = Image.new("RGB", (B30_ENTRY_WIDTH, B30_ENTRY_HEIGHT), 0)

        # draw the difficulty colored triangle on the jacket, instead of on the b30 image.
        # this ensures that the triangle is flush with the top right corner of the jacket instead of
        # being slightly off by 1-2 pixels
        difficulty_color = record.difficulty.color()
        jacket_draw = ImageDraw.Draw(jacket)
        jacket_draw.polygon(
            [
                (jacket.width - 55, 0),
                (jacket.width, 0),
                (jacket.width, 55),
            ],
            # difficulty_color is a number of type 0xRRGGBB, but Pillow expects 0xBBGGRR when
            # passing a number.
            (
                (difficulty_color >> 16) & 0xFF,
                (difficulty_color >> 8) & 0xFF,
                difficulty_color & 0xFF,
            ),
        )

        # add a gaussian blurred shadow onto the jacket
        jacket_shadow = jacket_shadow_base.copy()

        jacket_shadow.paste(jacket, (10, 10))

        jacket_padded = Image.new("RGBA", (b30_image.width, b30_image.height))

        jacket_padded.paste(jacket_shadow, (x - 10, y - 10), jacket_shadow)

        # finally, paste the edited jacket onto the image.
        b30_image = Image.alpha_composite(b30_image, jacket_padded)
        b30_draw = ImageDraw.Draw(b30_image)

        # if the title doesn't fit the b30 entry rectangle, shorten it until it fits.
        title = record.title
        title_length = b30_draw.textlength(title, NOTO_SANS_JP_32_BOLD)

        while title_length > B30_ENTRY_WIDTH - 15:
            title = title[:-1]
            title_length = b30_draw.textlength(title + "...", NOTO_SANS_JP_32_BOLD)

        # draw the title
        b30_draw.text(
            (x + 10, y + 7),
            title + ("..." if title != record.title else ""),
            fill="#FFFFFF",
            font=NOTO_SANS_JP_32_BOLD,
        )

        # draw the score
        b30_draw.text(
            (x + 10, y + 47),
            f"{record.score:,}",
            fill="#FFFFFF",
            font=NOTO_SANS_JP_32_BOLD,
        )

        # draw the rank, next to the score
        lamps = f"[{record.rank}]"

        if record.combo_lamp == ComboType.ALL_JUSTICE_CRITICAL:
            lamps += " [AJC]"
        elif record.combo_lamp == ComboType.ALL_JUSTICE:
            lamps += " [AJ]"
        elif record.combo_lamp == ComboType.FULL_COMBO:
            lamps += " [FC]"

        b30_draw.text(
            (
                x
                + 10
                + b30_draw.textlength(f"{record.score:,}", NOTO_SANS_JP_32_BOLD)
                + 10,
                y + 50,
            ),
            lamps,
            fill="#FFFFFF",
            font=NOTO_SANS_JP_28_MEDIUM,
        )

        # draw judgements, if they're available
        if isinstance(record, DetailedRecentRecord):
            b30_draw.text(
                (x + 10, y + 89),
                f"{record.extras.get(KEY_INTERNAL_LEVEL):.1f} | {record.judgements.jcrit} – {record.judgements.justice} – {record.judgements.attack} – {record.judgements.miss}",  # noqa: RUF001
                fill="#FFFFFF",
                font=NOTO_SANS_JP_28_MEDIUM,
            )

        # draw the rank of the b30 entry
        b30_draw.text(
            (x + 10, y + 125),
            f"#{i + 1}",
            fill="#FFFFFF",
            font=NOTO_SANS_JP_32_BOLD,
        )

        # draw the internal level and rating value
        if isinstance(record, DetailedRecentRecord):
            rating_text = f"({record.extras.get(KEY_PLAY_RATING)})"
        else:
            rating_text = f"({record.extras.get(KEY_INTERNAL_LEVEL):.1f} > {record.extras.get(KEY_PLAY_RATING)})"

        b30_draw.text(
            (
                x + 10 + b30_draw.textlength(f"#{i + 1}", NOTO_SANS_JP_32_BOLD) + 10,
                y + 128,
            ),
            rating_text,
            fill="#FFFFFF",
            font=NOTO_SANS_JP_28_MEDIUM,
        )

        # draw the timestamp
        if isinstance(record, RecentRecord) and record.date.timestamp() > 0:
            difference = datetime.now(UTC) - record.date

            if difference.days >= 365:
                delta = f"{difference.days // 365}y"
            elif difference.days >= 30:
                delta = f"{difference.days // 30}mo"
            elif difference.days >= 1:
                delta = f"{difference.days}d"
            elif difference.seconds >= 3600:
                delta = f"{difference.seconds // 3600}h"
            elif difference.seconds >= 60:
                delta = f"{difference.seconds // 60}m"
            elif difference.seconds >= 1:
                delta = f"{difference.seconds}s"
            else:
                delta = "0s"

            delta_length = b30_draw.textlength(delta, NOTO_SANS_JP_28_MEDIUM)

            b30_draw.text(
                (int(x + B30_ENTRY_WIDTH - delta_length - 10), y + 128),
                delta,
                fill="#FFFFFF",
                font=NOTO_SANS_JP_28_MEDIUM,
            )

    # crop any extra bits we don't need, however we might need them later...
    b30_image = b30_image.crop((0, 0, b30_image.width, 1429))

    buffer = BytesIO()

    b30_image.save(buffer, "PNG", optimize=True)
    buffer.seek(0)

    return buffer


class RecordsCog(commands.Cog, name="Records"):
    def __init__(self, bot: "ChuniBot") -> None:
        self.bot = bot
        self.utils: "UtilsCog" = self.bot.get_cog("Utils")  # type: ignore[reportGeneralTypeIssues]
        self.autocompleters: "AutocompletersCog" = self.bot.get_cog("Autocompleters")  # type: ignore[reportGeneralTypeIssues]

    async def _recent_inner(
        self,
        ctx: Context,
        user: discord.User | discord.Member | None = None,
        *,
        kamaitachi: bool = False,
    ):
        target_id = ctx.author.id if user is None else user.id

        async with ctx.typing():
            if kamaitachi:
                async with self.utils.kamaitachi_client(target_id) as client:
                    resp = await client.get("https://kamai.tachi.ac/api/v1/users/me")
                    data = resp.json()

                    if not data["success"]:
                        msg = f"Could not get user information from Kamaitachi: {data['success']}"
                        raise commands.CommandError(msg)

                    username = data["body"]["username"]

                    resp = await client.get(
                        "https://kamai.tachi.ac/api/v1/users/me/games/chunithm/Single/scores/recent"
                    )
                    data = resp.json()

                    if not data["success"]:
                        msg = f"Could not retrieve recent scores from Kamaitachi: {data['description']}"
                        raise commands.CommandError(msg)

                    recents = convert_kt_scores_to_records(data["body"])
                    recents = await self.utils.hydrate_records(recents)

                    view = B30View(
                        ctx,
                        recents,
                        show_average=False,
                        show_reachable=False,
                        show_lamps=True,
                    )
                    view.message = await ctx.reply(
                        content=f"Most recent scores for {username} on Kamaitachi:",
                        embeds=view.format_page(view.items[: view.per_page]),
                        view=view,
                        mention_author=False,
                    )
                    return

            ctxmgr = self.utils.chuninet(target_id)
            client = await ctxmgr.__aenter__()
            userinfo = await client.authenticate()
            recents = await client.recent_record()

            if len(recents) == 0:
                await ctx.reply(
                    f"No recent scores found for {userinfo.name}.", mention_author=False
                )
                return

            hydrated_recents = await self.utils.hydrate_records(recents)

            view = RecentRecordsView(
                ctx, self.bot, hydrated_recents, client, ctxmgr, userinfo
            )
            view.message = await ctx.reply(
                content=f"Most recent credits for {userinfo.name}:",
                embeds=view.format_score_page(view.items[0]),
                view=view,
                mention_author=False,
            )

    @commands.command(name="recent", aliases=["rs"])
    async def recent(self, ctx: Context, *, query: str = ""):
        """View your recent scores.

        **Parameters**:
        `user`: The user to get scores for.
        `-k, --kamaitachi`: Get recent scores from Kamaitachi, if the user has that linked.
        """

        parser = DiscordArguments()
        parser.add_argument("-k", "--kamaitachi", action="store_true")

        try:
            args, rest = await parser.parse_known_intermixed_args(shlex_split(query))
        except ArgumentError as e:
            raise commands.BadArgument(str(e)) from e

        user = None

        if len(rest) > 0:
            for converter in [commands.MemberConverter, commands.UserConverter]:
                with contextlib.suppress(commands.BadArgument):
                    user = await converter().convert(ctx, rest[0])
                    break

        await self._recent_inner(ctx, user, kamaitachi=args.kamaitachi)

    @app_commands.command(name="recent", description="View recent scores")
    @app_commands.allowed_installs(guilds=True, users=True)
    @app_commands.describe(
        user="The user to get recent scores for",
        kamaitachi="Get recent scores from Kamaitachi, if linked",
    )
    async def recent_slash(
        self,
        interaction: Interaction,
        user: discord.User | discord.Member | None = None,
        *,
        kamaitachi: bool = False,
    ):
        ctx = await Context.from_interaction(interaction)

        return await self._recent_inner(ctx, user, kamaitachi=kamaitachi)

    async def _compare_inner(
        self,
        ctx: Context,
        user: discord.User | discord.Member | None = None,
        *,
        kamaitachi: bool = False,
    ):
        target_id = ctx.author.id if user is None else user.id

        async with ctx.typing(), self.bot.begin_db_session() as session:
            if ctx.message.reference is not None:
                message = await ctx.channel.fetch_message(
                    cast(int, ctx.message.reference.message_id)
                )
            else:
                try:
                    messages = [
                        x
                        async for x in ctx.channel.history(limit=50)
                        if x.author == self.bot.user
                        and any(
                            e.thumbnail.url is not None
                            and (
                                JACKET_BASE in e.thumbnail.url
                                or INTERNATIONAL_JACKET_BASE in e.thumbnail.url
                            )
                            for e in x.embeds
                        )
                    ]
                except discord.errors.Forbidden as e:
                    msg = (
                        "Bot requires the Read Message History permission to fetch recent scores. "
                        f"Alternatively, run `{ctx.prefix}compare` while replying to the score you want to compare."
                    )
                    raise commands.CheckFailure(msg) from e

                if len(messages) == 0:
                    msg = "No recent scores found."
                    raise commands.BadArgument(msg)

                message = messages[0]

            thumbnail_urls = []
            for e in message.embeds:
                if e.thumbnail.url is not None:
                    thumbnail_urls.append(e.thumbnail.url)
                elif e.image.url is not None:
                    thumbnail_urls.append(e.image.url)

            if len(thumbnail_urls) == 0:
                msg = "The message replied to does not contain any charts/scores."
                raise commands.BadArgument(msg)

            sql = (
                select(SongJacket)
                .where(SongJacket.jacket_url.in_(thumbnail_urls))
                .options(joinedload(SongJacket.song))
            )
            jackets = (await session.execute(sql)).scalars().all()

            if len(jackets) == 0:
                await ctx.reply("No song found.", mention_author=False)
                return

            if len(jackets) > 1:
                view = SelectToCompareView(
                    [(x.song.title, i) for i, x in enumerate(jackets)]
                )
                compare_message = await ctx.reply(
                    "Select a score to compare with:", view=view, mention_author=False
                )

                await view.wait()

                if view.value is None:
                    await compare_message.edit(
                        content="Timed out before selecting a score.",
                        view=None,
                        allowed_mentions=AllowedMentions.none(),
                    )
                    return

                jacket = jackets[int(view.value)]
                song = jacket.song
            else:
                compare_message = None
                jacket = jackets[0]
                song = jacket.song

            if not kamaitachi:
                song.raise_if_not_available()

            embed = next(
                x
                for x in message.embeds
                if jacket.jacket_url in {x.thumbnail.url, x.image.url}
            )

            if kamaitachi:
                if song.genre == "WORLD'S END":
                    embed = discord.Embed(
                        title="Error",
                        description="Kamaitachi does not support WORLD'S END charts.",
                        color=discord.Color.red(),
                    )

                    if compare_message is not None:
                        await compare_message.edit(
                            content=None,
                            embed=embed,
                            allowed_mentions=AllowedMentions.none(),
                        )
                        return

                    await ctx.reply(embed=embed, mention_author=False)
                    return

                async with self.utils.kamaitachi_client(target_id) as client:
                    resp = await client.get("https://kamai.tachi.ac/api/v1/users/me")
                    data = resp.json()

                    if not data["success"]:
                        msg = f"Could not get user information from Kamaitachi: {data['success']}"
                        raise commands.CommandError(msg)

                    username = data["body"]["username"]

                    resp = await client.get(
                        f"https://kamai.tachi.ac/api/v1/users/me/games/chunithm/Single/pbs?search={urllib.parse.quote(song.title)}"
                    )
                    data = resp.json()

                    if not data["success"]:
                        msg = f"Could not get scores from Kamaitachi: {data['success']}"
                        raise commands.CommandError(msg)

                    raw_records = convert_kt_pbs_to_records(data["body"])

                    if len(raw_records) == 0:
                        await ctx.reply(
                            f"No records found for {username} on **{escape_markdown(song.title)}** on Kamaitachi.",
                            mention_author=False,
                        )
                        return

                    network = " on Kamaitachi"
                    records = [
                        pb for pb in raw_records if pb.extras[KEY_SONG_ID] == song.id
                    ]
                    records = await self.utils.hydrate_records(records)
                    records.sort(key=lambda r: r.difficulty.value)
            else:
                async with self.utils.chuninet(target_id) as client:
                    userinfo = await client.authenticate()
                    username = userinfo.name
                    network = ""
                    records = await client.music_record(song.id)

                    if len(records) == 0:
                        await ctx.reply(
                            f"No records found for {userinfo.name}.",
                            mention_author=False,
                        )
                        return

                    records = await self.utils.hydrate_records(records)

            page = 0
            try:
                # intentionally passing an invalid color so it throws and keep the page at 0
                difficulty = Difficulty.from_embed_color(
                    embed.color.value if embed.color else 0  # type: ignore[attr-defined]
                )
                page = next(
                    (
                        i
                        for i, record in enumerate(records)
                        if record.difficulty == difficulty
                    ),
                    0,
                )
            except ValueError:
                pass

            view = CompareView(ctx, records)
            view.page = page

            if compare_message is not None:
                view.message = compare_message
                await compare_message.edit(
                    content=f"Top play for {username}{network}:",
                    embed=ScoreCardEmbed(view.items[view.page]),
                    view=view,
                    allowed_mentions=AllowedMentions.none(),
                )
                return
            view.message = await ctx.reply(
                content=f"Top play for {username}{network}:",
                embed=ScoreCardEmbed(view.items[view.page]),
                view=view,
                mention_author=False,
            )
            return

    @commands.command("compare", aliases=["c"])
    async def compare(self, ctx: Context, *, query: str = ""):
        """Compare your best score with another score.

        By default, it's the most recently posted score. You can reply to another
        user's score to compare with that instead. If there are multiple scores in
        said message, you will be prompted to select one.

        **Tip**: This command also works with some other bots (<@986651489529397279> and <@604641359416131585>
        to name a few). However, you will need to explicitly reply to those other bots' messages.
        If you don't reply, only recent scores *from this bot* will be checked.

        **Parameters**
        user: The user to compare with (defaults to you).
        `-k, --kamaitachi`: Get scores from Kamaitachi, if the target user has a linked account.
        """

        parser = DiscordArguments()
        parser.add_argument("-k", "--kamaitachi", action="store_true")

        try:
            args, rest = await parser.parse_known_intermixed_args(shlex_split(query))
        except ArgumentError as e:
            raise commands.BadArgument(str(e)) from e

        user = None

        if len(rest) > 0:
            for converter in [commands.MemberConverter, commands.UserConverter]:
                with contextlib.suppress(commands.BadArgument):
                    user = await converter().convert(ctx, rest[0])
                    break

        await self._compare_inner(ctx, user, kamaitachi=args.kamaitachi)

    @app_commands.command(
        name="compare", description="Compare your best score with another score."
    )
    @app_commands.describe(
        user="The user to compare with (defaults to you)",
        kamaitachi="Get scores from Kamaitachi, if the target user has a linked account",
    )
    async def compare_slash(
        self,
        interaction: discord.Interaction,
        user: discord.User | discord.Member | None = None,
        *,
        kamaitachi: bool = False,
    ):
        ctx = await Context.from_interaction(interaction)

        await self._compare_inner(ctx, user, kamaitachi=kamaitachi)

    async def song_title_autocomplete(
        self, interaction: discord.Interaction, current: str
    ) -> list[app_commands.Choice[str]]:
        return await self.autocompleters.song_title_autocomplete(interaction, current)

    async def _scores_inner(
        self,
        ctx: Context,
        query: str,
        user: discord.User | discord.Member | None = None,
        *,
        kamaitachi: bool = False,
    ):
        target_id = ctx.author.id if user is None else user.id

        async with ctx.typing():
            guild_id = ctx.guild.id if ctx.guild else None
            result = await self.utils.find_songs(
                query, guild_id=guild_id, load_charts=True
            )

            if result.similarity < SIMILARITY_THRESHOLD:
                return await ctx.reply(
                    did_you_mean_text(result.songs[0], result.matched_alias),
                    mention_author=False,
                )

            # if we're fetching scores from Kamaitachi, we don't need to care about whether
            # the song is available in CHUNITHM International.
            #
            # However, we need to keep in mind that Kamaitachi does not support WORLD'S END.
            songs = [
                x
                for x in result.songs
                if (kamaitachi and x.genre != "WORLD'S END")
                or (not kamaitachi and x.available)
            ]

            if len(songs) > 1:
                options = []

                for i, x in enumerate(songs):
                    if x.genre == "WORLD'S END":
                        title = f"{x.title} [{x.charts[0].level}]"
                    else:
                        title = x.title

                    options.append((title, i))
                view = SelectToCompareView(
                    options=options,
                    placeholder="Select a song...",
                )
                select_message = await ctx.reply(
                    "Multiple songs were found. Select one:",
                    view=view,
                    mention_author=False,
                )

                await view.wait()

                if view.value is None:
                    await select_message.edit(
                        content="Timed out before selecting a song.",
                        view=None,
                        allowed_mentions=AllowedMentions.none(),
                    )
                    return None

                song = songs[int(view.value)]
            elif len(songs) > 0:
                song = songs[0]
                select_message = None
            else:
                msg = f"No songs currently available in CHUNITHM International matches the search criteria. Closest match was **{escape_markdown(result.songs[0].title)}**."
                raise commands.BadArgument(msg)

            if kamaitachi:
                async with self.utils.kamaitachi_client(target_id) as client:
                    resp = await client.get("https://kamai.tachi.ac/api/v1/users/me")
                    data = resp.json()

                    if not data["success"]:
                        msg = f"Could not get user information from Kamaitachi: {data['success']}"
                        raise commands.CommandError(msg)

                    username = data["body"]["username"]

                    resp = await client.get(
                        f"https://kamai.tachi.ac/api/v1/users/me/games/chunithm/Single/pbs?search={urllib.parse.quote(song.title)}"
                    )
                    data = resp.json()

                    if not data["success"]:
                        msg = f"Could not get scores from Kamaitachi: {data['success']}"
                        raise commands.CommandError(msg)

                    raw_records = convert_kt_pbs_to_records(data["body"])

                    if len(raw_records) == 0:
                        await ctx.reply(
                            f"No records found for {username} on **{escape_markdown(song.title)}** on Kamaitachi.",
                            mention_author=False,
                        )
                        return None

                    network = " on Kamaitachi"
                    records = [
                        pb for pb in raw_records if pb.extras[KEY_SONG_ID] == song.id
                    ]
                    records = await self.utils.hydrate_records(records)
                    records.sort(key=lambda r: r.difficulty.value)
            else:
                async with self.utils.chuninet(target_id) as client:
                    user_info = await client.authenticate()
                    username = user_info.name
                    network = ""
                    records = await client.music_record(song.id)

                    if len(records) == 0:
                        await ctx.reply(
                            f"No records found for {user_info.name} on **{escape_markdown(song.title)}**.",
                            mention_author=False,
                        )
                        return None

                    records = await self.utils.hydrate_records(records)

            view = CompareView(ctx, records)

            if select_message is None:
                view.message = await ctx.reply(
                    content=f"Top play for {username}{network}:",
                    embed=ScoreCardEmbed(view.items[view.page]),
                    view=view,
                    mention_author=False,
                )
            else:
                view.message = await select_message.edit(
                    content=f"Top play for {username}{network}:",
                    embed=ScoreCardEmbed(view.items[view.page]),
                    view=view,
                    allowed_mentions=AllowedMentions.none(),
                )

            return None

    @commands.command("scores")
    async def scores(
        self,
        ctx: Context,
        *,
        query: str = "",
    ):
        """Get a player's scores for a specific song.

        **Parameters**:
        `user` (not required): The user to get scores for. Must go first if specified.
        `query` (required): The song to search for. You don't have to be exact; try things out!
        `-k, --kamaitachi`: Get scores from Kamaitachi, if the user has that linked.
        """

        parser = DiscordArguments()
        parser.add_argument("-k", "--kamaitachi", action="store_true")

        try:
            args, rest = await parser.parse_known_intermixed_args(shlex_split(query))
        except ArgumentError as e:
            raise commands.BadArgument(str(e)) from e

        user = None

        if len(rest) > 0:
            for converter in [commands.MemberConverter, commands.UserConverter]:
                with contextlib.suppress(commands.BadArgument):
                    user = await converter().convert(ctx, rest[0])
                    break

        if user is not None:
            if len(rest) < 2:
                msg = "You have not specified a song to search for."
                raise commands.BadArgument(msg)
            query = " ".join(rest[1:])
        else:
            query = " ".join(rest)

        await self._scores_inner(ctx, query, user, kamaitachi=args.kamaitachi)

    @app_commands.command(
        name="scores",
        description="Get personal bests for a specific song",
    )
    @app_commands.describe(
        query="The song to search for. You don't have to be exact; try things out!",
        user="The user to get scores for.",
        kamaitachi="Get scores from Kamaitachi, if the user has that linked.",
    )
    @app_commands.allowed_installs(guilds=True, users=True)
    @app_commands.autocomplete(query=song_title_autocomplete)
    async def scores_slash(
        self,
        interaction: discord.Interaction,
        query: str,
        user: discord.User | discord.Member | None = None,
        *,
        kamaitachi: bool = False,
    ):
        ctx = await Context.from_interaction(interaction)

        await self._scores_inner(ctx, query, user, kamaitachi=kamaitachi)

    async def _best30_inner(
        self,
        ctx: Context,
        user: discord.User | discord.Member | None = None,
        *,
        image: bool = False,
        kamaitachi: bool = False,
    ):
        target_id = ctx.author.id if user is None else user.id

        async with ctx.typing():
            if kamaitachi:
                async with self.utils.kamaitachi_client(target_id) as client:
                    resp = await client.get("https://kamai.tachi.ac/api/v1/users/me")
                    data = resp.json()
                    player_name = data["body"]["username"]

                    resp = await client.get(
                        "https://kamai.tachi.ac/api/v1/users/me/games/chunithm/Single/pbs/best?alg=rating"
                    )
                    data = resp.json()

                if not data["success"]:
                    msg = f"Could not retrieve your best scores from Kamaitachi: {data['description']}"
                    raise commands.CommandError(msg)

                pbs = convert_kt_pbs_to_records(data["body"])
                best30 = pbs[:30]
                current_rating = None
                max_rating = None

                best30 = await self.utils.hydrate_records(best30)
            else:
                async with self.utils.chuninet(target_id) as client:
                    player_data = await client.player_data()
                    player_name = player_data.name
                    current_rating = player_data.rating.current
                    max_rating = player_data.rating.max
                    best30 = await client.best30()
                    best30 = await self.utils.hydrate_records(best30)

            if not image:
                view = B30View(ctx, best30)
                view.message = await ctx.reply(
                    content=view.format_content(),
                    embeds=view.format_page(view.items[: view.per_page]),
                    view=view,
                    mention_author=False,
                )
                return

            b30_image = await asyncio.to_thread(
                render_b30,
                player_name,
                best30,
                current_rating=current_rating,
                max_rating=max_rating,
            )
            generation_timestamp = datetime.now(UTC).strftime("%Y-%m-%d_%H-%M-%S")
            await ctx.reply(
                file=discord.File(
                    b30_image, filename=f"chuni-penguin-b30-{generation_timestamp}.png"
                ),
                mention_author=False,
            )

    @commands.command("best30", aliases=["b30"])
    async def best30(self, ctx: Context, *, query: str = ""):
        """View top 30 scores of you or another player.

        **Parameters**:
        `user`: The user to get scores for.
        `-i, --image`: Render an image of your best 30 scores instead of viewing
        with Discord embeds
        `-k, --kamaitachi`: Get the best 30 scores from Kamaitachi, if the user
        has that linked.
        """

        parser = DiscordArguments()
        parser.add_argument("-i", "--image", action="store_true")
        parser.add_argument("-k", "--kamaitachi", action="store_true")

        try:
            args, rest = await parser.parse_known_intermixed_args(shlex_split(query))
        except ArgumentError as e:
            raise commands.BadArgument(str(e)) from e

        user = None

        if len(rest) > 0:
            for converter in [commands.MemberConverter, commands.UserConverter]:
                with contextlib.suppress(commands.BadArgument):
                    user = await converter().convert(ctx, rest[0])
                    break

        await self._best30_inner(
            ctx, user, image=args.image, kamaitachi=args.kamaitachi
        )

    @app_commands.command(name="best30", description="View top plays")
    @app_commands.allowed_installs(guilds=True, users=True)
    @app_commands.describe(
        user="The user to get best30 for",
        image="Render an image of your best 30 scores",
        kamaitachi="Get your best 30 from Kamaitachi if linked",
    )
    async def best30_slash(
        self,
        interaction: Interaction,
        user: discord.User | discord.Member | None = None,
        *,
        image: bool = False,
        kamaitachi: bool = False,
    ):
        ctx = await Context.from_interaction(interaction)

        await self._best30_inner(ctx, user, image=image, kamaitachi=kamaitachi)

    @commands.hybrid_command("recent10", aliases=["r10"])
    async def recent10(
        self, ctx: Context, *, user: Optional[discord.User | discord.Member] = None
    ):
        """View top recent plays

        Parameters
        ----------
        user: Optional[discord.User | discord.Member]
            The user to get scores for.
        """

        async with ctx.typing(), self.utils.chuninet(
            ctx if user is None else user.id
        ) as client:
            recent10 = await client.recent10()
            recent10 = await self.utils.hydrate_records(recent10)

            view = B30View(ctx, recent10, show_reachable=False)
            view.message = await ctx.reply(
                content=view.format_content(),
                embeds=view.format_page(view.items[: view.per_page]),
                view=view,
                mention_author=False,
            )

    @commands.hybrid_command("new20", aliases=["n10", "n15", "n20", "new10", "new15"])
    async def new20(
        self, ctx: Context, *, user: Optional[discord.User | discord.Member] = None
    ):
        """Calculate your rating in the new CHUNITHM VERSE system (latest version is
        LUMINOUS PLUS).

        Parameters
        ----------
        user: Optional[discord.User | discord.Member]
            The user to get scores for.
        """

        ctx_or_id = ctx if user is None else user.id
        message = await ctx.reply("Fetching scores...", mention_author=False)
        all_records: list[Record] = []

        async with self.utils.chuninet(ctx_or_id) as client:
            for difficulty in Difficulty:
                if difficulty == Difficulty.WORLDS_END:
                    continue

                await message.edit(
                    content=f"Fetching {difficulty} scores...",
                    allowed_mentions=AllowedMentions.none(),
                )

                all_records.extend(
                    await client.music_record_by_folder(difficulty=difficulty)
                )

        hydrated_records = await self.utils.hydrate_records(all_records)
        old_records = [
            x
            for x in hydrated_records
            if x.extras.get(KEY_SONG_VERSION) != CURRENT_CHUNITHM_VERSION
        ]
        new_records = [
            x
            for x in hydrated_records
            if x.extras.get(KEY_SONG_VERSION) == CURRENT_CHUNITHM_VERSION
        ]

        old_records.sort(
            key=lambda x: (x.extras.get(KEY_PLAY_RATING), x.score), reverse=True
        )
        new_records.sort(
            key=lambda x: (x.extras.get(KEY_PLAY_RATING), x.score), reverse=True
        )

        best30 = old_records[:30]
        best30_total = sum(
            (item.extras[KEY_PLAY_RATING] for item in best30), Decimal(0)
        )
        best30_avg = (
            floor_to_ndp(best30_total / len(best30), 4)
            if len(best30) > 0
            else Decimal(0)
        )

        new20 = new_records[:20]
        new20_total = sum((item.extras[KEY_PLAY_RATING] for item in new20), Decimal(0))
        new20_avg = (
            floor_to_ndp(new20_total / len(new20), 4) if len(new20) > 0 else Decimal(0)
        )

        content = (
            f"**Best 30 average**: {best30_avg}\n"
            f"**New 20 average**: {new20_avg}\n"
            f"**Rating**: {floor_to_ndp((best30_total + new20_total) / 50, 2)}\n"
        )

        if len(new20) == 0:
            await message.edit(content=content, allowed_mentions=AllowedMentions.none())
        else:
            view = B30View(ctx, new20, show_reachable=False)
            view.message = await message.edit(
                content=content,
                embeds=view.format_page(view.items[: view.per_page]),
                view=view,
                allowed_mentions=AllowedMentions.none(),
            )

    @app_commands.command(name="top", description="View your best scores for a level.")
    @app_commands.describe(
        level="Level (from 1 to 15) to search for.",
        difficulty="Difficulty to search for.",
        genre="Genre to search for.",
        rank="Rank to search for.",
        sort="Sort records by a criteria (default rating).",
    )
    @app_commands.choices(
        level=[
            *[app_commands.Choice(name=str(i), value=str(i)) for i in range(1, 7)],
            *itertools.chain.from_iterable(
                [
                    (
                        app_commands.Choice(name=f"{i}", value=f"{i}"),
                        app_commands.Choice(name=f"{i}+", value=f"{i}+"),
                    )
                    for i in range(7, 15)
                ]
            ),
            app_commands.Choice(name="15", value="15"),
        ],
        difficulty=[
            app_commands.Choice(name=str(x), value=x.value)
            for x in Difficulty.__members__.values()
        ],  # type: ignore[reportGeneralTypeIssues]
        genre=[
            app_commands.Choice(name=str(x), value=x.value)
            for x in Genres.__members__.values()
        ],  # type: ignore[reportGeneralTypeIssues]
        rank=[
            app_commands.Choice(name=str(x), value=x.value)
            for x in Rank.__members__.values()
        ],  # type: ignore[reportGeneralTypeIssues]
    )
    async def top_slash(
        self,
        interaction: "discord.Interaction[ChuniBot]",
        *,
        user: Optional[discord.User | discord.Member] = None,
        level: Optional[str] = None,
        difficulty: Optional[Difficulty] = None,
        genre: Optional[Genres] = None,
        rank: Optional[Rank] = None,
        sort: Literal["rating", "score", "overpower", "overpower %"] = "rating",
    ):
        await interaction.response.defer()

        if (genre or rank) and not difficulty:
            return await interaction.followup.send(
                "Difficulty must be set if genre or rank is set."
            )

        async with self.utils.chuninet(
            interaction.user.id if user is None else user.id
        ) as client:
            records = await client.music_record_by_folder(
                level=level, genre=genre, difficulty=difficulty, rank=rank
            )
            assert records is not None

            if len(records) == 0:
                return await interaction.followup.send("No scores found.")

            records = await self.utils.hydrate_records(records)

            if sort == "rating":
                records.sort(
                    reverse=True,
                    key=lambda x: (
                        x.extras.get(KEY_PLAY_RATING),
                        x.score,
                        x.extras.get(KEY_OVERPOWER_BASE),
                    ),
                )
            elif sort == "score":
                records.sort(
                    reverse=True,
                    key=lambda x: (
                        x.score,
                        x.extras.get(KEY_PLAY_RATING),
                        x.extras.get(KEY_OVERPOWER_BASE),
                    ),
                )
            elif sort == "overpower":
                records.sort(
                    reverse=True,
                    key=lambda x: (
                        x.extras.get(KEY_OVERPOWER_BASE),
                        x.extras.get(KEY_PLAY_RATING),
                        x.score,
                    ),
                )
            elif sort == "overpower %":
                records.sort(
                    reverse=True,
                    key=lambda x: (
                        x.extras[KEY_OVERPOWER_BASE] / x.extras[KEY_OVERPOWER_MAX],
                        x.extras.get(KEY_OVERPOWER_BASE),
                        x.extras.get(KEY_PLAY_RATING),
                        x.score,
                    ),
                )
            else:
                msg = f"Invalid sort type {sort}. Expected one of score, rating, overpower, overpower %."
                raise commands.BadArgument(msg)

            ctx = await Context.from_interaction(interaction)
            view = B30View(ctx, records, show_average=False, show_reachable=False)
            view.message = await ctx.reply(
                content=view.format_content(),
                embeds=view.format_page(view.items[: view.per_page]),
                view=view,
            )
            return None

    @commands.command("top")
    async def top(
        self,
        ctx: Context,
        *,
        query: str,
    ):
        """
        **View your best scores for a level.**

        **Parameters:**
        `user`: Discord username of the player. Yourself, if not provided.
        `level`: Level (from 1 to 15) to search for.
        `-d`: Difficulty to search for. Must be one of `EASY`, `ADVANCED`, `EXPERT`, `MASTER`, `ULTIMA`, or `WE` if specified.
        `-g`: Genre to search for. Must be one of `POPS&ANIME`, `niconico`, `Touhou Project`, `ORIGINAL`, `VARIETY`, `Irodorimidori`, or `Gekimai`, if specified.
        `-r`: Rank to search for. Anywhere between "S" and "SSS+" (inclusive), if specified.
        `-s`: Choose a metric to sort scores by. Supported options are `score`, `rating`, `op`, `op_percent`.

        Genre and rank cannot be set at the same time. If genre or rank is set, difficulty must also be set.

        If multiple parameters are set, they will be applied in order of:
        - level
        - genre + difficulty
        - rank + difficulty
        - difficulty

        **Examples:**
        `c>top 14+`: View your best scores for level 14+
        `c>top -d mas`: View your best scores for MASTER difficulty
        `c>top -g original -d ultima`: View your best scores for ULTIMA difficulty in the ORIGINAL folder
        `c>top @player -r sss -d mas`: View @player's best scores for SSS rank on MASTER difficulty.
        """

        def genre(arg: str) -> Genres:
            genre = None
            genre_lower = arg.lower()
            if genre_lower.startswith("pops"):
                genre = Genres.POPS_AND_ANIME
            elif genre_lower.startswith("nico"):
                genre = Genres.NICONICO
            elif genre_lower.startswith(("touhou", "toho", "東方")):
                genre = Genres.TOUHOU_PROJECT
            elif genre_lower.startswith(("original", "chunithm")):
                genre = Genres.ORIGINAL
            elif genre_lower.startswith("variety"):
                genre = Genres.VARIETY
            elif genre_lower.startswith("irodori"):
                genre = Genres.IRODORIMIDORI
            elif genre_lower.startswith(("geki", "ゲキ")):
                genre = Genres.GEKIMAI
            else:
                msg = "Invalid genre."
                raise ValueError(msg)

            return genre

        def difficulty(arg: str) -> Difficulty:
            if arg.upper().startswith("WORLD"):
                return Difficulty.WORLDS_END
            return Difficulty.from_short_form(arg.upper()[:3])

        def rank(arg: str) -> Rank:
            return Rank[arg.upper().replace("+", "p")]

        def sort_type(arg: str) -> str:
            if arg not in {
                "score",
                "rating",
                "op",
                "op_percent",
                "overpower",
                "overpower_percent",
            }:
                msg = "Invalid sort type. Expected one of score, rating, op, op_percent, overpower, overpower_percent."
                raise ValueError(msg)

            return arg

        parser = DiscordArguments()
        parser.add_argument("-d", "--difficulty", type=difficulty, required=False)
        parser.add_argument("-s", "--sort", type=sort_type, required=False)

        group = parser.add_mutually_exclusive_group()
        group.add_argument("-g", "--genre", type=genre, required=False)
        group.add_argument("-r", "--rank", type=rank, required=False)

        try:
            args, rest = await parser.parse_known_intermixed_args(shlex_split(query))
        except ArgumentError as e:
            raise commands.BadArgument(str(e)) from e

        if (args.genre or args.rank) and not args.difficulty:
            msg = "Must specify a difficulty when searching by genre or rank."
            raise commands.BadArgument(msg)

        user = None
        str_level = None

        if len(rest) > 0:
            for converter in [commands.MemberConverter, commands.UserConverter]:
                with contextlib.suppress(commands.BadArgument):
                    user = await converter().convert(ctx, rest[0])
                    str_level = rest[1] if len(rest) > 1 else None
                    break

        if str_level is None:
            str_level = rest[0] if len(rest) > 0 else None

        level = None
        internal_level: float | None = None

        if str_level:
            # Three accepted use cases, "14", "14+" and "14.9"
            msg = "Invalid level."

            if "." in str_level and str_level.replace(".", "", 1).isdigit():
                internal_level = float(str_level)
                level = str(int(internal_level))

                if internal_level * 10 % 10 >= 5:
                    level += "+"
            elif str_level[-1] == "+" and str_level[:-1].isdigit():
                if int(str_level[:-1]) not in range(7, 15):
                    raise commands.BadArgument(msg)

                level = str_level
            elif str_level.isdigit():
                if int(str_level) not in range(1, 16):
                    raise commands.BadArgument(msg)

                level = str_level
            else:
                raise commands.BadArgument(msg)

        async with ctx.typing(), self.utils.chuninet(
            ctx if user is None else user.id
        ) as client:
            records = await client.music_record_by_folder(
                level=level,
                genre=args.genre,
                difficulty=args.difficulty,
                rank=args.rank,
            )
            assert records is not None

            if len(records) == 0:
                return await ctx.reply("No scores found.", mention_author=False)

            records = await self.utils.hydrate_records(records)

            if args.sort is None or args.sort == "rating":
                records.sort(
                    reverse=True,
                    key=lambda x: (
                        x.extras.get(KEY_PLAY_RATING),
                        x.score,
                        x.extras.get(KEY_OVERPOWER_BASE),
                    ),
                )
            elif args.sort == "score":
                records.sort(
                    reverse=True,
                    key=lambda x: (
                        x.score,
                        x.extras.get(KEY_PLAY_RATING),
                        x.extras.get(KEY_OVERPOWER_BASE),
                    ),
                )
            elif args.sort in {"overpower", "op"}:
                records.sort(
                    reverse=True,
                    key=lambda x: (
                        x.extras.get(KEY_OVERPOWER_BASE),
                        x.extras.get(KEY_PLAY_RATING),
                        x.score,
                    ),
                )
            elif args.sort in {"overpower_percent", "op_percent"}:
                records.sort(
                    reverse=True,
                    key=lambda x: (
                        x.extras[KEY_OVERPOWER_BASE] / x.extras[KEY_OVERPOWER_MAX],
                        x.extras.get(KEY_OVERPOWER_BASE),
                        x.extras.get(KEY_PLAY_RATING),
                        x.score,
                    ),
                )
            else:
                msg = f"Invalid sort type {args.sort}. Expected one of score, rating, op, op_percent, overpower, overpower_percent."
                raise commands.BadArgument(msg)

            if internal_level is not None:
                records = [
                    r
                    for r in records
                    if r.extras.get(KEY_INTERNAL_LEVEL) == internal_level
                ]

            view = B30View(ctx, records, show_average=False, show_reachable=False)
            view.message = await ctx.reply(
                content=view.format_content(),
                embeds=view.format_page(view.items[: view.per_page]),
                view=view,
                mention_author=False,
            )
            return None


async def setup(bot: "ChuniBot"):
    await bot.add_cog(RecordsCog(bot))
